#!/usr/bin/env python
import networkx as nx
from math import radians, cos, sin, asin, sqrt
import numpy as np
import matplotlib.pyplot as plt
import random
import data
import PathDelay
import sys
import math
test_num       = 1000                   # graph size
len_of_neigh   = int(sys.argv[3])       # outbound neighbors
len_of_test    = int(sys.argv[5])       # maximum neighbors may switch each round
len_of_subround= 100                    # how may subround under local simulation
#IncomingLimit  = 10                    # maximum incoming neighbors
RoundNum       = 130                    # how many rounds in simulation
DelayPercantage= 90                     # how do we score the performance of individual node
pathunlimit    = 2000                   # default delay between node during shortest path
unlimit        = 9999                   # how do we value the unresponded nodes
sys.setrecursionlimit(19999999)


        
# The LinkDelay is the edge latency, can be generated by 'GenerateWeightFile.py'
def ReadWeightFile(a):
    print('ReadWeightFile', a)
    WeightFileName="weight"+str(a)+".txt"
    LinkDelay=np.zeros([test_num,test_num])
    filew=open(WeightFileName,'r',errors='replace')
    line=filew.readlines()
    for i in range(test_num):
        a=line[i].split("  ")
        for j in range(test_num):
            LinkDelay[i][j]=a[j]
    filew.close()
    return(LinkDelay)

# The NodeHash are the edge latencies, can be generated by 'GenerateHashFile.py', the mean is 1
def ReadHashFile(a):
    HashFileName="hash"+str(a)+".txt"
    NodeHash=np.zeros(test_num)
    fileh=open(HashFileName,'r',errors='replace')
    line=fileh.readlines()
    a=line[0].split("  ")
    for j in range(test_num):
        NodeHash[j]=a[j]
    fileh.close()
    return(NodeHash)

# Select 20 nodes to build a low-latency subgraph with 10%'s latency but occupys 90%'s hash
def ReadLowLatencyNode(a,NodeHash,delay,LinkDelay):
    LowLatenncyNodeFileName="node"+str(a)+".txt"
    fileh=open(LowLatenncyNodeFileName,'r',errors='replace')
    line=fileh.readlines()
    a=line[0].split("  ")
    lowlatencynode=np.zeros(100)
    for i in range(len(a)-1):
        lowlatencynode[i]=int(a[i])-1
        if int(lowlatencynode[i])<test_num:
            delay[int(lowlatencynode[i])]      =   0.1*delay[int(lowlatencynode[i])]
            NodeHash[int(lowlatencynode[i])] =   81*NodeHash[int(lowlatencynode[i])]
    for i in range(len(lowlatencynode)):
        for j in range(len(lowlatencynode)):
            LinkDelay[i][j]=0.1*LinkDelay[i][j]
    # keep mean hash as 1
    NodeHash=NodeHash/9
    fileh.close()
    return(NodeHash,delay,LinkDelay)
    
def ReadTreeEdge(a,LinkDelay,delay):
    LowLatenncyNodeFileName="node"+str(a)+".txt"
    fileh=open(LowLatenncyNodeFileName,'r',errors='replace')
    lowlatencynode=np.zeros(100)
    line=fileh.readlines()
    b=line[0].split("  ")
    for i in range(len(b)-1):
        lowlatencynode[i]=int(b[i])-1
        if int(lowlatencynode[i])<test_num:
            delay[int(lowlatencynode[i])]      =   0.1*delay[int(lowlatencynode[i])]
    fileh.close()
    TreeFileName="tree"+str(a)+".txt"
    filew=open(TreeFileName,'r',errors='replace')
    line=filew.readlines()
    for i in range(99):
        a=line[i].split("  ")
        LinkDelay[int(lowlatencynode[int(a[0])])][int(lowlatencynode[int(a[1])])] = 0.1 * LinkDelay[int(lowlatencynode[int(a[0])])][int(lowlatencynode[int(a[1])])]
        LinkDelay[int(lowlatencynode[int(a[1])])][int(lowlatencynode[int(a[0])])] = 0.1 * LinkDelay[int(lowlatencynode[int(a[1])])][int(lowlatencynode[int(a[0])])]
    filew.close()
    return(LinkDelay,delay)



def Read(Datafile, NodeDelay, NetworkType):
    LinkDelay= ReadWeightFile(Datafile)
    #LinkDelay=   initnetwork.DelayByBandwidth(NeighborSets,bandwidth)
    NodeHash  = ReadHashFile(str(sys.argv[1]))
    if  str(NetworkType) == 'lowlatencyhash':
        [NodeHash,NodeDelay, LinkDelay]  =   ReadLowLatencyNode(str(sys.argv[1]),NodeHash,NodeDelay,LinkDelay)
    if  str(NetworkType) == 'treehash':
        [LinkDelay,NodeDelay] =   ReadTreeEdge(str(sys.argv[1]),LinkDelay,NodeDelay)

    return(LinkDelay,NodeHash,NodeDelay)

